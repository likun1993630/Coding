## 进程的概念

首先程序与进程是什么？程序与进程又有什么区别？

- 程序（procedure）：
  不太精确地说，程序就是执行一系列有逻辑、有顺序结构的指令，帮我们达成某个结果。就如我们去餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，最后我们得到了这么一盘牛肉盖浇饭。它需要去执行，不然它就像一本武功秘籍，放在那里等人翻看。
- 进程（process）：
  进程是程序在一个数据集合上的一次执行过程，在早期的UNIX、Linux 2.4及更早的版本中，它是系统进行资源分配和调度的独立基本单位。同上一个例子，就如我们去了餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，而里面做饭的是一个进程，做牛肉汤汁的是一个进程，把牛肉汤汁与饭混合在一起的是一个进程，把饭端上桌的是一个进程。它就像是我们在看武功秘籍这么一个过程，然后一个篇章一个篇章地去练。

简单来说，程序是为了完成某种任务而设计的软件，比如 vim 是程序。什么是进程呢？进程就是运行中的程序。

程序只是一些列指令的集合，是一个静止的实体，而进程不同，进程有以下的特性：

- 动态性：进程的实质是一次程序执行的过程，有创建、撤销等状态的变化。而程序是一个静态的实体。
- 并发性：进程可以做到在一个时间段内，有多个程序在运行中。程序只是静态的实体，所以不存在并发性。
- 独立性：进程可以独立分配资源，独立接受调度，独立地运行。
- 异步性：进程以不可预知的速度向前推进。
- 结构性：进程拥有代码段、数据段、PCB（进程控制块，进程存在的唯一标志）。也正是因为有结构性，进程才可以做到独立地运行。

> 并发：在一个时间段内，宏观来看有多个程序都在活动，有条不紊的执行（每一瞬间只有一个在执行，只是在一段时间有多个程序都执行过）
> 并行：在每一个瞬间，都有多个程序都在同时执行，这个必须有多个 CPU 才行

引入进程是因为传统意义上的程序已经不足以描述 OS 中各种活动之间的动态性、并发性、独立性还有相互制约性。程序就像一个公司，只是一些证书，文件的堆积（静态实体）。而当公司运作起来就有各个部门的区分，财务部，技术部，销售部等等，就像各个进程，各个部门之间可以独立运做，也可以有交互（独立性、并发性）。

而随着程序的发展越做越大，又会继续细分，从而引入了线程的概念，当代多数操作系统、Linux 2.6及更新的版本中，进程本身不是基本运行单位，而是线程的容器。就像上述所说的，每个部门又会细分为各个工作小组（线程），而工作小组需要的资源需要向上级（进程）申请。

> 线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。因为线程中几乎不包含系统资源，所以执行更快、更有效率。

简而言之,一个程序至少有一个进程,一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。就如下图所示：

![](./res/Process.png)

### 进程的分类 
可以从两个角度来分：

- 以进程的功能与服务的对象来分；
- 以应用程序的服务类型来分；

第一个角度来看，我们可以分为用户进程与系统进程：

- 用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。
- 系统进程：通过执行系统内核程序而产生的进程，比如可以执行内存资源分配和进程切换等相对底层的工作；而且该进程的运行不受用户的干预，即使是 root 用户也不能干预系统进程的运行。

第二角度来看，我们可以将进程分为交互进程、批处理进程、守护进程:

- 交互进程：由一个 shell 终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。
- 批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。
- 守护进程：守护进程是一直运行的一种进程，在 Linux 系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。例如 httpd 进程，一直处于运行状态，等待用户的访问。还有经常用的 cron（在 centOS 系列为 crond）进程，这个进程为 crontab 的守护进程，可以周期性的执行用户设定的某些任务。

### 进程的衍生
进程有这么多的种类，那么进程之间定是有相关性的，而这些有关联性的进程又是如何产生的，如何衍生的？

就比如我们启动了终端，就是启动了一个 bash 进程，我们可以在 bash 中再输入 bash 则会再启动一个 bash 的进程，此时第二个 bash 进程就是由第一个 bash 进程创建出来的，他们之间又是个什么关系？

我们一般称呼第一个 bash 进程是第二 bash 进程的父进程，第二 bash 进程是第一个 bash 进程的子进程，这层关系是如何得来的呢？

关于父进程与子进程便会提及这两个系统调用 fork() 与 exec()

- fork() 是一个系统调用（system call），它的主要作用就是为当前的进程创建一个新的进程，这个新的进程就是它的子进程，这个子进程除了父进程的返回值和 PID 以外其他的都一模一样，如进程的执行代码段，内存信息，文件描述，寄存器状态等等
- exec() 也是系统调用，作用是切换子进程中的执行程序也就是替换其从父进程复制过来的代码段与数据段

子进程就是父进程通过系统调用 fork() 而产生的复制品，fork() 就是把父进程的 PCB 等进程的数据结构信息直接复制过来，只是修改了 PID，所以一模一样，只有在执行 exec() 之后才会不同，而早先的 fork() 比较消耗资源后来进化成 vfork(),效率高了不少。

进程 0 是系统引导时创建的一个特殊进程，也称之为内核初始化，其最后一个动作就是调用 fork() 创建出一个子进程运行 /sbin/init 可执行文件,而该进程就是 PID=1 的进程 1，而进程 0 就转为交换进程（也被称为空闲进程），进程 1 （init 进程）是第一个用户态的进程，再由它不断调用 fork() 来创建系统里其他的进程，所以它是所有进程的父进程或者祖先进程。同时它是一个守护程序，直到计算机关机才会停止。

通过命令查看进程树：
```shell
$ pstree
```

另一种方式：
```shell
$ ps －fxo user,ppid,pid,pgid,command


USER      PPID   PID  PGID COMMAND
....
root         0     1     1 /sbin/init splash
....
likun     1580  7169  1666      \_ /usr/lib/gnome-terminal/gnome-terminal-server
likun     7169  7174  7174          \_ zsh
likun     7174  7445  7445              \_ ps -fxo user,ppid,pid,pgid,command
....
```
>  pid 就是该进程的一个唯一编号，ppid 就是该进程的父进程的 pid，command 表示的是该进程通过执行什么样的命令或者脚本而产生的.PGID（process group ID）为进程组。
>  执行的 ps 就是由 zsh 通过 fork-exec 创建的子进程而执行的
>  init 如上文所说是由进程 0 这个初始化进程来创建出来的子进程,而其他的进程基本是由 init 创建的子进程，或者是由它的子进程创建出来的子进程。所以 init 是用户进程的第一个进程也是所有用户进程的父进程或者祖先进程。

### 进程组与 Sessions 
每一个进程都会是一个进程组的成员，而且这个进程组是唯一存在的，他们是依靠 PGID（process group ID）来区别的，而每当一个进程被创建的时候，它便会成为其父进程所在组中的一员。

一般情况，进程组的 PGID 等同于进程组的第一个成员的 PID，并且这样的进程称为该进程组的领导者,也就是领导进程，进程一般通过使用 getpgrp() 系统调用来寻找其所在组的 PGID，领导进程可以先终结，此时进程组依然存在，并持有相同的PGID，直到进程组中最后一个进程终结。

与进程组类似，每当一个进程被创建的时候，它便会成为其父进程所在 Session 中的一员，每一个进程组都会在一个 Session 中，并且这个 Session 是唯一存在的.



> 前台（foreground）就是在终端中运行，能与你有交互的
> 后台（background）就是在终端中运行，但是你并不能与其任何的交互，也不会显示其执行的过程



## 进程查看
不管在测试的时候、在实际的生产环境中，还是自己的使用过程中，难免会遇到一些进程异常的情况，所以 Linux 为我们提供了一些工具来查看进程的状态信息。我们可以通过 top 实时的查看进程的状态，以及系统的一些信息（如 CPU、内存信息等），我们还可以通过 ps 来静态查看当前的进程信息，同时我们还可以使用 pstree 来查看当前活跃进程的树形结构。

###  top 工具的使用 
```shell
$ top
```
top 是一个在前台执行的程序，所以执行后便进入到这样的一个交互界面，正是因为交互界面我们才可以实时的获取到系统与进程的信息。在交互界面中我们可以通过一些指令来操作和筛选。在此之前我们先来了解显示了哪些信息。

top 显示的第一排:

| 内容                         | 解释                                |
|------------------------------|-------------------------------------|
| top                          | 表示当前程序的名称                  |
| 11:05:18                     | 表示当前的系统的时间                |
| up 8 days,17:12              | 表示该机器已经启动了多长时间        |
| 1 user                       | 表示当前系统中只有一个用户          |
| load average: 0.29,0.20,0.25 | 分别对应1、5、15分钟内cpu的平均负载 |

load average 在 wikipedia 中的解释是 the system load is a measure of the amount of work that a computer system is doing 也就是对当前 CPU 工作量的度量，具体来说也就是指运行队列的平均长度，也就是等待 CPU 的平均进程数相关的一个计算值。

我们该如何看待这个load average 数据呢？

假设我们的系统是单 CPU、单内核的，把它比喻成是一条单向的桥，把CPU任务比作汽车。

- load = 0 的时候意味着这个桥上并没有车，cpu 没有任何任务；
- load < 1 的时候意味着桥上的车并不多，一切都还是很流畅的，cpu 的任务并不多，资源还很充足；
- load = 1 的时候就意味着桥已经被车给占满了，没有一点空隙，cpu 的已经在全力工作了，所有的资源都被用完了，当然还好，这还在能力范围之内，只是有点慢而已；
- load > 1 的时候就意味着不仅仅是桥上已经被车占满了，就连桥外都被占满了，cpu 已经在全力工作，系统资源的用完了，但是还是有大量的进程在请求，在等待。若是这个值大于２、大于３，表示进程请求超过 CPU 工作能力的 2 到 ３ 倍。而若是这个值 > 5 说明系统已经在超负荷运作了。

这是单个 CPU 单核的情况，而实际生活中我们需要将得到的这个值除以我们的核数来看。我们可以通过以下的命令来查看 CPU 的个数与核心数

```shell
#查看物理CPU的个数
#cat /proc/cpuinfo |grep "physical id"|sort |uniq|wc -l

#每个cpu的核心数
cat /proc/cpuinfo |grep "physical id"|grep "0"|wc -l
```


通过上面的指数我们可以得知 load 的临界值为 1 ，但是在实际生活中，比较有经验的运维或者系统管理员会将临界值定为0.7。这里的指数都是除以核心数以后的值，不要混淆了

- 若是 load < 0.7 并不会去关注他；
- 若是 0.7< load < 1 的时候我们就需要稍微关注一下了，虽然还可以应付但是这个值已经离临界不远了；
- 若是 load = 1 的时候我们就需要警惕了，因为这个时候已经没有更多的资源的了，已经在全力以赴了；
- 若是 load > 5 的时候系统已经快不行了，这个时候你需要加班解决问题了


top 的第二行数据，基本上第二行是进程的一个情况统计

| 内容            | 解释                |
|-----------------|---------------------|
| Tasks: 26 total | 进程总数            |
| 1 running       | 1个正在运行的进程数 |
| 25 sleeping     | 25个睡眠的进程数    |
| 0 stopped       | 没有停止的进程数    |
| 0 zombie        | 没有僵尸进程数      |

top 的第三行数据，这一行基本上是 CPU 的一个使用情况的统计

| 内容           | 解释                                                                          |
|----------------|-------------------------------------------------------------------------------|
| Cpu(s): 1.0%us | 用户空间进程占用CPU百分比                                                     |
| 1.0% sy        | 内核空间运行占用CPU百分比                                                     |
| 0.0%ni         | 用户进程空间内改变过优先级的进程占用CPU百分比                                 |
| 97.9%id        | 空闲CPU百分比                                                                 |
| 0.0%wa         | 等待输入输出的CPU时间百分比                                                   |
| 0.1%hi         | 硬中断(Hardware IRQ)占用CPU的百分比                                           |
| 0.0%si         | 软中断(Software IRQ)占用CPU的百分比                                           |
| 0.0%st         | (Steal time) 是 hypervisor 等虚拟服务中，虚拟 CPU 等待实际 CPU 的时间的百分比 |

> CPU 利用率是对一个时间段内 CPU 使用状况的统计，通过这个指标可以看出在某一个时间段内 CPU 被占用的情况，而 Load Average 是 CPU 的 Load，它所包含的信息不是 CPU 的使用率状况，而是在一段时间内 CPU 正在处理以及等待 CPU 处理的进程数情况统计信息，这两个指标并不一样。

top 的第四行数据，这一行基本上是内存的一个使用情况的统计：

| 内容           | 解释                 |
|----------------|----------------------|
| 8176740 total  | 物理内存总量         |
| 8032104 used   | 使用的物理内存总量   |
| 144636 free    | 空闲内存总量         |
| 313088 buffers | 用作内核缓存的内存量 |

> 注意:系统中可用的物理内存最大值并不是 free 这个单一的值，而是 free + buffers + swap 中的 cached 的和

top 的第五行数据，这一行基本上是交换区的一个使用情况的统计:

| 内容   | 解释                                                                                        |
|--------|---------------------------------------------------------------------------------------------|
| total  | 交换区总量                                                                                  |
| used   | 使用的交换区总量                                                                            |
| free   | 空闲交换区总量                                                                              |
| cached | 缓冲的交换区总量,内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖 |

下面是进程情况：

| 列名    | 解释                                         |
|---------|----------------------------------------------|
| PID     | 进程id                                       |
| USER    | 该进程的所属用户                             |
| PR      | 该进程执行的优先级 priority 值               |
| NI      | 该进程的 nice 值                             |
| VIRT    | 该进程任务所使用的虚拟内存的总数             |
| RES     | 该进程所使用的物理内存数，也称之为驻留内存数 |
| SHR     | 该进程共享内存的大小                         |
| S       | 该进程进程的状态: S=sleep R=running Z=zombie |
| %CPU    | 该进程CPU的利用率                            |
| %MEM    | 该进程内存的利用率                           |
| TIME+   | 该进程活跃的总时间                           |
| COMMAND | 该进程运行的名字                             |


> NICE 值叫做静态优先级，是用户空间的一个优先级值，其取值范围是-20至19。这个值越小，表示进程”优先级”越高，而值越大“优先级”越低。nice值中的 -20 到 19，中 -20 优先级最高， 0 是默认的值，而 19 优先级最低

> PR 值表示 Priority 值叫动态优先级，是进程在内核中实际的优先级值，进程优先级的取值范围是通过一个宏定义的，这个宏的名称是 MAX_PRIO，它的值为 140。Linux 实际上实现了 140 个优先级范围，取值范围是从 0-139，这个值越小，优先级越高。而这其中的 0 - 99 是实时进程的值，而 100 - 139 是给用户的。

> 其中 PR 中的 100 to 139 值部分有这么一个对应 PR = 20 + (-20 to +19)，这里的 -20 to +19 便是nice值，所以说两个虽然都是优先级，而且有千丝万缕的关系，但是他们的值，他们的作用范围并不相同

> ** VIRT **任务所使用的虚拟内存的总数，其中包含所有的代码，数据，共享库和被换出 swap空间的页面等所占据空间的总数


top 是一个前台程序，所以是一个可以交互的:

| 常用交互命令 | 解释                                                                                                                       |
|--------------|----------------------------------------------------------------------------------------------------------------------------|
| q            | 退出程序                                                                                                                   |
| I            | 切换显示平均负载和启动时间的信息                                                                                           |
| P            | 根据CPU使用百分比大小进行排序                                                                                              |
| M            | 根据驻留内存大小进行排序                                                                                                   |
| i            | 忽略闲置和僵死的进程，这是一个开关式命令                                                                                   |
| k            | 终止一个进程，系统提示输入 PID 及发送的信号值。一般终止进程用 15 信号，不能正常结束则使用 9 信号。安全模式下该命令被屏蔽。 |


### ps 工具的使用

```shell
$ ps aux
$ ps axjf
```

结果中的关键字含义：

| 内容      | 解释                                                                                                                          |
|-----------|-------------------------------------------------------------------------------------------------------------------------------|
| F         | 进程的标志（process flags），当 flags 值为 1 则表示此子程序只是 fork 但没有执行 exec，为 4 表示此程序使用超级管理员 root 权限 |
| USER      | 进程的拥有用户                                                                                                                |
| PID       | 进程的 ID                                                                                                                     |
| PPID      | 其父进程的 PID                                                                                                                |
| SID       | session 的 ID                                                                                                                 |
| TPGID     | 前台进程组的 ID                                                                                                               |
| %CPU      | 进程占用的 CPU 百分比                                                                                                         |
| %MEM      | 占用内存的百分比                                                                                                              |
| NI        | 进程的 NICE 值                                                                                                                |
| VSZ       | 进程使用虚拟内存大小                                                                                                          |
| RSS       | 驻留内存中页的大小                                                                                                            |
| TTY       | 终端 ID                                                                                                                       |
| S or STAT | 进程状态                                                                                                                      |
| WCHAN     | 正在等待的进程资源                                                                                                            |
| START     | 启动进程的时间                                                                                                                |
| TIME      | 进程消耗CPU的时间                                                                                                             |
| COMMAND   | 命令的名称和参数                                                                                                              |

> TPGID栏写着-1的都是没有控制终端的进程，也就是守护进程

STAT表示进程的状态，而进程的状态有很多，如下表所示:

| 状态 | 解释                               |
|------|------------------------------------|
| R    | Running.运行中                     |
| S    | Interruptible Sleep.等待调用       |
| D    | Uninterruptible Sleep.不可中断睡眠 |
| T    | Stoped.暂停或者跟踪状态            |
| X    | Dead.即将被撤销                    |
| Z    | Zombie.僵尸进程                    |
| W    | Paging.内存交换                    |
| N    | 优先级低的进程                     |
| <    | 优先级高的进程                     |
| s    | 进程的领导者                       |
| L    | 锁定状态                           |
| l    | 多线程状态                         |
| +    | 前台进程                           |

> 其中的 D 是不能被中断睡眠的状态，处在这种状态的进程不接受外来的任何 signal，所以无法使用 kill 命令杀掉处于D状态的进程，无论是 kill，kill -9 还是 kill -15，一般处于这种状态可能是进程 I/O 的时候出问题了。

ps 常用参数

- ps -l
  使用 -l 参数可以显示自己这次登陆的 bash 相关的进程信息罗列出来
  
- ps aux
  将会罗列出所有的进程信息
  > 若是查找其中的某个进程的话，我们还可以配合着 grep 和正则表达式一起使用
  > `ps aux | grep zsh`
 
- ps axjf
  将连同部分的进程呈树状显示出来
  > 自定义所需要的参数显示
  > `ps -afxo user,ppid,pid,pgid,command`


### pstree 工具的使用 
通过 pstree 可以很直接的看到相同的进程数量，最主要的还是我们可以看到所有进程之间的相关性。

```shell
$ pstree
```

参数使用：
```shell
pstree -up

#参数选择：
#-A  ：各程序树之间以 ASCII 字元來連接；
#-p  ：同时列出每个 process 的 PID；
#-u  ：同时列出每个 process 的所屬账户名称。
```

## 进程管理

### kill 命令
当一个进程结束的时候或者要异常结束的时候，会向其父进程返回一个或者接收一个 SIGHUP 信号而做出的结束进程或者其他的操作，这个 SIGHUP 信号不仅可以由系统发送，我们可以使用 kill 来发送这个信号来操作进程的结束或者重启等等。

直接kill pid
```shell
#首先我们使用图形界面打开了 gedit、gvim，用 ps 可以查看到
ps aux


likun     8171  0.2  0.3 635160 53232 pts/1    Sl+  22:35   0:00 gedit
```

```shell
#使用9这个信号强制结束 gedit 进程
kill -9 8171

#我们再查找这个进程的时候就找不到了
ps aux | grep gedit 
```

### 进程的执行顺序 
我们在使用 ps 命令的时候可以看到大部分的进程都是处于休眠的状态，如果这些进程都被唤醒，那么该谁最先享受 CPU 的服务，后面的进程又该是一个什么样的顺序呢？进程调度的队列又该如何去排列呢？

当然就是靠该进程的优先级值来判定进程调度的优先级，而优先级的值就是上文所提到的 PR 与 nice 来控制与体现了

而 nice 的值我们是可以通过 nice 命令来修改的，而需要注意的是 nice 值可以调整的范围是 -20 ~ 19，其中 root 有着至高无上的权力，既可以调整自己的进程也可以调整其他用户的程序，并且是所有的值都可以用，而普通用户只可以调制属于自己的进程，并且其使用的范围只能是 0 ~ 19，因为系统为了避免一般用户抢占系统资源而设置的一个限制

```shell
#打开一个程序放在后台，或者用图形界面打开
nice -n -5 vim &

#用 ps 查看其优先级
ps -afxo user,ppid,pid,stat,pri,ni,time,command | grep vim
```

```shell
#我们还可以用 renice 来修改已经存在的进程的优先级
renice -5 pid
```

